import{t as U,u as D,v as Tt,L as ut,w as P,E as rt,h as b,x as tt,B as Q,R as st}from"./worker-BR_GWEAC.js";class et{}et._UpdateFlagSeed=0;function Ft(G,t,s,i=0){const n=G.asArray(),o=t.asArray(),r=n[0],e=n[1],a=n[2],_=n[3],c=n[4],m=n[5],x=n[6],w=n[7],f=n[8],F=n[9],I=n[10],p=n[11],d=n[12],L=n[13],l=n[14],k=n[15],A=o[0],C=o[1],g=o[2],N=o[3],q=o[4],E=o[5],H=o[6],O=o[7],M=o[8],X=o[9],Y=o[10],J=o[11],Z=o[12],B=o[13],j=o[14],W=o[15];s[i]=r*A+e*q+a*M+_*Z,s[i+1]=r*C+e*E+a*X+_*B,s[i+2]=r*g+e*H+a*Y+_*j,s[i+3]=r*N+e*O+a*J+_*W,s[i+4]=c*A+m*q+x*M+w*Z,s[i+5]=c*C+m*E+x*X+w*B,s[i+6]=c*g+m*H+x*Y+w*j,s[i+7]=c*N+m*O+x*J+w*W,s[i+8]=f*A+F*q+I*M+p*Z,s[i+9]=f*C+F*E+I*X+p*B,s[i+10]=f*g+F*H+I*Y+p*j,s[i+11]=f*N+F*O+I*J+p*W,s[i+12]=d*A+L*q+l*M+k*Z,s[i+13]=d*C+L*E+l*X+k*B,s[i+14]=d*g+L*H+l*Y+k*j,s[i+15]=d*N+L*O+l*J+k*W}function lt(G,t,s=0){const i=G.asArray();t[s]=i[0],t[s+1]=i[1],t[s+2]=i[2],t[s+3]=i[3],t[s+4]=i[4],t[s+5]=i[5],t[s+6]=i[6],t[s+7]=i[7],t[s+8]=i[8],t[s+9]=i[9],t[s+10]=i[10],t[s+11]=i[11],t[s+12]=i[12],t[s+13]=i[13],t[s+14]=i[14],t[s+15]=i[15]}function pt(G,t){const s=G.asArray(),i=s[0],n=s[1],o=s[2],r=s[3],e=s[4],a=s[5],_=s[6],c=s[7],m=s[8],x=s[9],w=s[10],f=s[11],F=s[12],I=s[13],p=s[14],d=s[15],L=w*d-p*f,l=x*d-I*f,k=x*p-I*w,A=m*d-F*f,C=m*p-w*F,g=m*I-F*x,N=+(a*L-_*l+c*k),q=-(e*L-_*A+c*C),E=+(e*l-a*A+c*g),H=-(e*k-a*C+_*g),O=i*N+n*q+o*E+r*H;if(O===0)return!1;const M=1/O,X=_*d-p*c,Y=a*d-I*c,J=a*p-I*_,Z=e*d-F*c,B=e*p-F*_,j=e*I-F*a,W=_*f-w*c,K=a*f-x*c,V=a*w-x*_,it=e*f-m*c,nt=e*w-m*_,ot=e*x-m*a,at=-(n*L-o*l+r*k),ht=+(i*L-o*A+r*C),_t=-(i*l-n*A+r*g),ct=+(i*k-n*C+o*g),yt=+(n*X-o*Y+r*J),mt=-(i*X-o*Z+r*B),Rt=+(i*Y-n*Z+r*j),xt=-(i*J-n*B+o*j),ft=-(n*W-o*K+r*V),zt=+(i*W-o*it+r*nt),dt=-(i*K-n*it+r*ot),wt=+(i*V-n*nt+o*ot);return t[0]=N*M,t[1]=at*M,t[2]=yt*M,t[3]=ft*M,t[4]=q*M,t[5]=ht*M,t[6]=mt*M,t[7]=zt*M,t[8]=E*M,t[9]=_t*M,t[10]=Rt*M,t[11]=dt*M,t[12]=H*M,t[13]=ct*M,t[14]=xt*M,t[15]=wt*M,!0}const S=G=>parseInt(G.toString().replace(/\W/g,""));class T{constructor(t=0,s=0){this.x=t,this.y=s}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const t=S(this.x),s=S(this.y);let i=t;return i=i*397^s,i}toArray(t,s=0){return t[s]=this.x,t[s+1]=this.y,this}fromArray(t,s=0){return T.FromArrayToRef(t,s,this),this}asArray(){return[this.x,this.y]}copyFrom(t){return this.x=t.x,this.y=t.y,this}copyFromFloats(t,s){return this.x=t,this.y=s,this}set(t,s){return this.copyFromFloats(t,s)}setAll(t){return this.copyFromFloats(t,t)}add(t){return new T(this.x+t.x,this.y+t.y)}addToRef(t,s){return s.x=this.x+t.x,s.y=this.y+t.y,s}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addInPlaceFromFloats(t,s){return this.x+=t,this.y+=s,this}addVector3(t){return new T(this.x+t.x,this.y+t.y)}subtract(t){return new T(this.x-t.x,this.y-t.y)}subtractToRef(t,s){return s.x=this.x-t.x,s.y=this.y-t.y,s}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new T(this.x*t.x,this.y*t.y)}multiplyToRef(t,s){return s.x=this.x*t.x,s.y=this.y*t.y,s}multiplyByFloats(t,s){return new T(this.x*t,this.y*s)}divide(t){return new T(this.x/t.x,this.y/t.y)}divideToRef(t,s){return s.x=this.x/t.x,s.y=this.y/t.y,s}divideInPlace(t){return this.x=this.x/t.x,this.y=this.y/t.y,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.x,t.y)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.x,t.y)}minimizeInPlaceFromFloats(t,s){return this.x=Math.min(t,this.x),this.y=Math.min(s,this.y),this}maximizeInPlaceFromFloats(t,s){return this.x=Math.max(t,this.x),this.y=Math.max(s,this.y),this}subtractFromFloats(t,s){return new T(this.x-t,this.y-s)}subtractFromFloatsToRef(t,s,i){return i.x=this.x-t,i.y=this.y-s,i}negate(){return new T(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){return new T(this.x*t,this.y*t)}scaleToRef(t,s){return s.x=this.x*t,s.y=this.y*t,s}scaleAndAddToRef(t,s){return s.x+=this.x*t,s.y+=this.y*t,s}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t,s=U){return t&&D(this.x,t.x,s)&&D(this.y,t.y,s)}equalsToFloats(t,s){return this.x===t&&this.y===s}floor(){return new T(Math.floor(this.x),Math.floor(this.y))}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t}fract(){return new T(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t}rotate(t){return this.rotateToRef(t,new T)}rotateToRef(t,s){const i=Math.cos(t),n=Math.sin(t);return s.x=i*this.x-n*this.y,s.y=n*this.x+i*this.y,s}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new T;return this.normalizeToRef(t),t}normalizeToRef(t){const s=this.length();return s===0&&(t.x=this.x,t.y=this.y),this.scaleToRef(1/s,t)}clone(){return new T(this.x,this.y)}dot(t){return this.x*t.x+this.y*t.y}static Zero(){return new T(0,0)}static One(){return new T(1,1)}static Random(t=0,s=1){return new T(P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s))}static get ZeroReadOnly(){return T._ZeroReadOnly}static FromArray(t,s=0){return new T(t[s],t[s+1])}static FromArrayToRef(t,s,i){return i.x=t[s],i.y=t[s+1],i}static FromFloatsToRef(t,s,i){return i.copyFromFloats(t,s),i}static CatmullRom(t,s,i,n,o){const r=o*o,e=o*r,a=.5*(2*s.x+(-t.x+i.x)*o+(2*t.x-5*s.x+4*i.x-n.x)*r+(-t.x+3*s.x-3*i.x+n.x)*e),_=.5*(2*s.y+(-t.y+i.y)*o+(2*t.y-5*s.y+4*i.y-n.y)*r+(-t.y+3*s.y-3*i.y+n.y)*e);return new T(a,_)}static ClampToRef(t,s,i,n){return n.x=b(t.x,s.x,i.x),n.y=b(t.y,s.y,i.y),n}static Clamp(t,s,i){const n=b(t.x,s.x,i.x),o=b(t.y,s.y,i.y);return new T(n,o)}static Hermite(t,s,i,n,o){const r=o*o,e=o*r,a=2*e-3*r+1,_=-2*e+3*r,c=e-2*r+o,m=e-r,x=t.x*a+i.x*_+s.x*c+n.x*m,w=t.y*a+i.y*_+s.y*c+n.y*m;return new T(x,w)}static Hermite1stDerivative(t,s,i,n,o){return this.Hermite1stDerivativeToRef(t,s,i,n,o,new T)}static Hermite1stDerivativeToRef(t,s,i,n,o,r){const e=o*o;return r.x=(e-o)*6*t.x+(3*e-4*o+1)*s.x+(-e+o)*6*i.x+(3*e-2*o)*n.x,r.y=(e-o)*6*t.y+(3*e-4*o+1)*s.y+(-e+o)*6*i.y+(3*e-2*o)*n.y,r}static Lerp(t,s,i){return T.LerpToRef(t,s,i,new T)}static LerpToRef(t,s,i,n){return n.x=t.x+(s.x-t.x)*i,n.y=t.y+(s.y-t.y)*i,n}static Dot(t,s){return t.x*s.x+t.y*s.y}static Normalize(t){return T.NormalizeToRef(t,new T)}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Minimize(t,s){const i=t.x<s.x?t.x:s.x,n=t.y<s.y?t.y:s.y;return new T(i,n)}static Maximize(t,s){const i=t.x>s.x?t.x:s.x,n=t.y>s.y?t.y:s.y;return new T(i,n)}static Transform(t,s){return T.TransformToRef(t,s,new T)}static TransformToRef(t,s,i){const n=s.m,o=t.x*n[0]+t.y*n[4]+n[12],r=t.x*n[1]+t.y*n[5]+n[13];return i.x=o,i.y=r,i}static PointInTriangle(t,s,i,n){const o=.5*(-i.y*n.x+s.y*(-i.x+n.x)+s.x*(i.y-n.y)+i.x*n.y),r=o<0?-1:1,e=(s.y*n.x-s.x*n.y+(n.y-s.y)*t.x+(s.x-n.x)*t.y)*r,a=(s.x*i.y-s.y*i.x+(s.y-i.y)*t.x+(i.x-s.x)*t.y)*r;return e>0&&a>0&&e+a<2*o*r}static Distance(t,s){return Math.sqrt(T.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y;return i*i+n*n}static Center(t,s){return T.CenterToRef(t,s,new T)}static CenterToRef(t,s,i){return i.copyFromFloats((t.x+s.x)/2,(t.y+s.y)/2)}static DistanceOfPointFromSegment(t,s,i){const n=T.DistanceSquared(s,i);if(n===0)return T.Distance(t,s);const o=i.subtract(s),r=Math.max(0,Math.min(1,T.Dot(t.subtract(s),o)/n)),e=s.add(o.multiplyByFloats(r,r));return T.Distance(t,e)}}T._V8PerformanceHack=new T(.5,.5);T._ZeroReadOnly=T.Zero();Object.defineProperties(T.prototype,{dimension:{value:[2]},rank:{value:1}});class h{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(t=0,s=0,i=0){this._isDirty=!0,this._x=t,this._y=s,this._z=i}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const t=S(this._x),s=S(this._y),i=S(this._z);let n=t;return n=n*397^s,n=n*397^i,n}asArray(){return[this._x,this._y,this._z]}toArray(t,s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,this}fromArray(t,s=0){return h.FromArrayToRef(t,s,this),this}toQuaternion(){return z.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._isDirty=!0,this}addInPlaceFromFloats(t,s,i){return this._x+=t,this._y+=s,this._z+=i,this._isDirty=!0,this}add(t){return new h(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,s){return s._x=this._x+t._x,s._y=this._y+t._y,s._z=this._z+t._z,s._isDirty=!0,s}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}subtract(t){return new h(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,s){return this.subtractFromFloatsToRef(t._x,t._y,t._z,s)}subtractFromFloats(t,s,i){return new h(this._x-t,this._y-s,this._z-i)}subtractFromFloatsToRef(t,s,i,n){return n._x=this._x-t,n._y=this._y-s,n._z=this._z-i,n._isDirty=!0,n}negate(){return new h(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t._x=this._x*-1,t._y=this._y*-1,t._z=this._z*-1,t._isDirty=!0,t}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new h(this._x*t,this._y*t,this._z*t)}scaleToRef(t,s){return s._x=this._x*t,s._y=this._y*t,s._z=this._z*t,s._isDirty=!0,s}getNormalToRef(t){const s=this.length();let i=Math.acos(this._y/s);const n=Math.atan2(this._z,this._x);i>Math.PI/2?i-=Math.PI/2:i+=Math.PI/2;const o=s*Math.sin(i)*Math.cos(n),r=s*Math.cos(i),e=s*Math.sin(i)*Math.sin(n);return t.set(o,r,e),t}applyRotationQuaternionToRef(t,s){const i=this._x,n=this._y,o=this._z,r=t._x,e=t._y,a=t._z,_=t._w,c=2*(e*o-a*n),m=2*(a*i-r*o),x=2*(r*n-e*i);return s._x=i+_*c+e*x-a*m,s._y=n+_*m+a*c-r*x,s._z=o+_*x+r*m-e*c,s._isDirty=!0,s}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new h)}scaleAndAddToRef(t,s){return s._x+=this._x*t,s._y+=this._y*t,s._z+=this._z*t,s._isDirty=!0,s}projectOnPlane(t,s){return this.projectOnPlaneToRef(t,s,new h)}projectOnPlaneToRef(t,s,i){const n=t.normal,o=t.d,r=R.Vector3[0];this.subtractToRef(s,r),r.normalize();const e=h.Dot(r,n);if(Math.abs(e)<1e-10)i.setAll(1/0);else{const a=-(h.Dot(s,n)+o)/e,_=r.scaleInPlace(a);s.addToRef(_,i)}return i}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t,s=U){return t&&D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)}equalsToFloats(t,s,i){return this._x===t&&this._y===s&&this._z===i}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,s){return s._x=this._x*t._x,s._y=this._y*t._y,s._z=this._z*t._z,s._isDirty=!0,s}multiplyByFloats(t,s,i){return new h(this._x*t,this._y*s,this._z*i)}divide(t){return new h(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,s){return s._x=this._x/t._x,s._y=this._y/t._y,s._z=this._z/t._z,s._isDirty=!0,s}divideInPlace(t){return this._x=this._x/t._x,this._y=this._y/t._y,this._z=this._z/t._z,this._isDirty=!0,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,s,i){return t<this._x&&(this.x=t),s<this._y&&(this.y=s),i<this._z&&(this.z=i),this}maximizeInPlaceFromFloats(t,s,i){return t>this._x&&(this.x=t),s>this._y&&(this.y=s),i>this._z&&(this.z=i),this}isNonUniformWithinEpsilon(t){const s=Math.abs(this._x),i=Math.abs(this._y);if(!D(s,i,t))return!0;const n=Math.abs(this._z);return!D(s,n,t)||!D(i,n,t)}get isNonUniform(){const t=Math.abs(this._x),s=Math.abs(this._y);if(t!==s)return!0;const i=Math.abs(this._z);return t!==i}floorToRef(t){return t._x=Math.floor(this._x),t._y=Math.floor(this._y),t._z=Math.floor(this._z),t._isDirty=!0,t}floor(){return new h(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(t){return t._x=this._x-Math.floor(this._x),t._y=this._y-Math.floor(this._y),t._z=this._z-Math.floor(this._z),t._isDirty=!0,t}fract(){return new h(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){if(t=t.toLowerCase(),t==="xyz")return this;const s=R.Vector3[0].copyFrom(this);return this.x=s[t[0]],this.y=s[t[1]],this.z=s[t[2]],this}rotateByQuaternionToRef(t,s){return t.toRotationMatrix(R.Matrix[0]),h.TransformCoordinatesToRef(this,R.Matrix[0],s),s}rotateByQuaternionAroundPointToRef(t,s,i){return this.subtractToRef(s,R.Vector3[0]),R.Vector3[0].rotateByQuaternionToRef(t,R.Vector3[0]),s.addToRef(R.Vector3[0],i),i}cross(t){return h.CrossToRef(this,t,new h)}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new h)}normalizeToRef(t){const s=this.length();return s===0||s===1?(t._x=this._x,t._y=this._y,t._z=this._z,t._isDirty=!0,t):this.scaleToRef(1/s,t)}clone(){return new h(this._x,this._y,this._z)}copyFrom(t){return this.copyFromFloats(t._x,t._y,t._z)}copyFromFloats(t,s,i){return this._x=t,this._y=s,this._z=i,this._isDirty=!0,this}set(t,s,i){return this.copyFromFloats(t,s,i)}setAll(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,s,i,n){const o=h.Dot(t,i),r=h.Dot(s,i);return(o-n)/(o-r)}static GetAngleBetweenVectors(t,s,i){const n=t.normalizeToRef(R.Vector3[1]),o=s.normalizeToRef(R.Vector3[2]);let r=h.Dot(n,o);r=b(r,-1,1);const e=Math.acos(r),a=R.Vector3[3];return h.CrossToRef(n,o,a),h.Dot(a,i)>0?isNaN(e)?0:e:isNaN(e)?-Math.PI:-Math.acos(r)}static GetAngleBetweenVectorsOnPlane(t,s,i){R.Vector3[0].copyFrom(t);const n=R.Vector3[0];R.Vector3[1].copyFrom(s);const o=R.Vector3[1];R.Vector3[2].copyFrom(i);const r=R.Vector3[2],e=R.Vector3[3],a=R.Vector3[4];n.normalize(),o.normalize(),r.normalize(),h.CrossToRef(r,n,e),h.CrossToRef(e,r,a);const _=Math.atan2(h.Dot(o,e),h.Dot(o,a));return Tt(_)}static PitchYawRollToMoveBetweenPointsToRef(t,s,i){const n=$.Vector3[0];return s.subtractToRef(t,n),i._y=Math.atan2(n.x,n.z)||0,i._x=Math.atan2(Math.sqrt(n.x**2+n.z**2),n.y)||0,i._z=0,i._isDirty=!0,i}static PitchYawRollToMoveBetweenPoints(t,s){const i=h.Zero();return h.PitchYawRollToMoveBetweenPointsToRef(t,s,i)}static SlerpToRef(t,s,i,n){i=b(i,0,1);const o=R.Vector3[0],r=R.Vector3[1];o.copyFrom(t);const e=o.length();o.normalizeFromLength(e),r.copyFrom(s);const a=r.length();r.normalizeFromLength(a);const _=h.Dot(o,r);let c,m;if(_<1-U){const x=Math.acos(_),w=1/Math.sin(x);c=Math.sin((1-i)*x)*w,m=Math.sin(i*x)*w}else c=1-i,m=i;return o.scaleInPlace(c),r.scaleInPlace(m),n.copyFrom(o).addInPlace(r),n.scaleInPlace(ut(e,a,i)),n}static SmoothToRef(t,s,i,n,o){return h.SlerpToRef(t,s,n===0?1:i/n,o),o}static FromArray(t,s=0){return new h(t[s],t[s+1],t[s+2])}static FromFloatArray(t,s){return h.FromArray(t,s)}static FromArrayToRef(t,s,i){return i._x=t[s],i._y=t[s+1],i._z=t[s+2],i._isDirty=!0,i}static FromFloatArrayToRef(t,s,i){return h.FromArrayToRef(t,s,i)}static FromFloatsToRef(t,s,i,n){return n.copyFromFloats(t,s,i),n}static Zero(){return new h(0,0,0)}static One(){return new h(1,1,1)}static Up(){return new h(0,1,0)}static get UpReadOnly(){return h._UpReadOnly}static get DownReadOnly(){return h._DownReadOnly}static get RightReadOnly(){return h._RightReadOnly}static get LeftReadOnly(){return h._LeftReadOnly}static get LeftHandedForwardReadOnly(){return h._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return h._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return h._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return h._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return h._ZeroReadOnly}static get OneReadOnly(){return h._OneReadOnly}static Down(){return new h(0,-1,0)}static Forward(t=!1){return new h(0,0,t?-1:1)}static Backward(t=!1){return new h(0,0,t?1:-1)}static Right(){return new h(1,0,0)}static Left(){return new h(-1,0,0)}static Random(t=0,s=1){return new h(P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s),P(t,s))}static TransformCoordinates(t,s){const i=h.Zero();return h.TransformCoordinatesToRef(t,s,i),i}static TransformCoordinatesToRef(t,s,i){return h.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformCoordinatesFromFloatsToRef(t,s,i,n,o){const r=n.m,e=t*r[0]+s*r[4]+i*r[8]+r[12],a=t*r[1]+s*r[5]+i*r[9]+r[13],_=t*r[2]+s*r[6]+i*r[10]+r[14],c=1/(t*r[3]+s*r[7]+i*r[11]+r[15]);return o._x=e*c,o._y=a*c,o._z=_*c,o._isDirty=!0,o}static TransformNormal(t,s){const i=h.Zero();return h.TransformNormalToRef(t,s,i),i}static TransformNormalToRef(t,s,i){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformNormalFromFloatsToRef(t,s,i,n,o){const r=n.m;return o._x=t*r[0]+s*r[4]+i*r[8],o._y=t*r[1]+s*r[5]+i*r[9],o._z=t*r[2]+s*r[6]+i*r[10],o._isDirty=!0,o}static CatmullRom(t,s,i,n,o){const r=o*o,e=o*r,a=.5*(2*s._x+(-t._x+i._x)*o+(2*t._x-5*s._x+4*i._x-n._x)*r+(-t._x+3*s._x-3*i._x+n._x)*e),_=.5*(2*s._y+(-t._y+i._y)*o+(2*t._y-5*s._y+4*i._y-n._y)*r+(-t._y+3*s._y-3*i._y+n._y)*e),c=.5*(2*s._z+(-t._z+i._z)*o+(2*t._z-5*s._z+4*i._z-n._z)*r+(-t._z+3*s._z-3*i._z+n._z)*e);return new h(a,_,c)}static Clamp(t,s,i){const n=new h;return h.ClampToRef(t,s,i,n),n}static ClampToRef(t,s,i,n){let o=t._x;o=o>i._x?i._x:o,o=o<s._x?s._x:o;let r=t._y;r=r>i._y?i._y:r,r=r<s._y?s._y:r;let e=t._z;return e=e>i._z?i._z:e,e=e<s._z?s._z:e,n.copyFromFloats(o,r,e),n}static CheckExtends(t,s,i){s.minimizeInPlace(t),i.maximizeInPlace(t)}static Hermite(t,s,i,n,o){const r=o*o,e=o*r,a=2*e-3*r+1,_=-2*e+3*r,c=e-2*r+o,m=e-r,x=t._x*a+i._x*_+s._x*c+n._x*m,w=t._y*a+i._y*_+s._y*c+n._y*m,f=t._z*a+i._z*_+s._z*c+n._z*m;return new h(x,w,f)}static Hermite1stDerivative(t,s,i,n,o){const r=new h;return this.Hermite1stDerivativeToRef(t,s,i,n,o,r),r}static Hermite1stDerivativeToRef(t,s,i,n,o,r){const e=o*o;return r._x=(e-o)*6*t._x+(3*e-4*o+1)*s._x+(-e+o)*6*i._x+(3*e-2*o)*n._x,r._y=(e-o)*6*t._y+(3*e-4*o+1)*s._y+(-e+o)*6*i._y+(3*e-2*o)*n._y,r._z=(e-o)*6*t._z+(3*e-4*o+1)*s._z+(-e+o)*6*i._z+(3*e-2*o)*n._z,r._isDirty=!0,r}static Lerp(t,s,i){const n=new h(0,0,0);return h.LerpToRef(t,s,i,n),n}static LerpToRef(t,s,i,n){return n._x=t._x+(s._x-t._x)*i,n._y=t._y+(s._y-t._y)*i,n._z=t._z+(s._z-t._z)*i,n._isDirty=!0,n}static Dot(t,s){return t._x*s._x+t._y*s._y+t._z*s._z}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}static Cross(t,s){const i=new h;return h.CrossToRef(t,s,i),i}static CrossToRef(t,s,i){const n=t._y*s._z-t._z*s._y,o=t._z*s._x-t._x*s._z,r=t._x*s._y-t._y*s._x;return i.copyFromFloats(n,o,r),i}static Normalize(t){const s=h.Zero();return h.NormalizeToRef(t,s),s}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Project(t,s,i,n){const o=new h;return h.ProjectToRef(t,s,i,n,o),o}static ProjectToRef(t,s,i,n,o){const r=n.width,e=n.height,a=n.x,_=n.y,c=R.Matrix[1],m=rt.LastCreatedEngine?.isNDCHalfZRange,x=m?1:.5,w=m?0:.5;y.FromValuesToRef(r/2,0,0,0,0,-e/2,0,0,0,0,x,0,a+r/2,e/2+_,w,1,c);const f=R.Matrix[0];return s.multiplyToRef(i,f),f.multiplyToRef(c,f),h.TransformCoordinatesToRef(t,f,o),o}static Reflect(t,s){return this.ReflectToRef(t,s,new h)}static ReflectToRef(t,s,i){const n=$.Vector3[0];return n.copyFrom(s).scaleInPlace(2*h.Dot(t,s)),i.copyFrom(t).subtractInPlace(n)}static UnprojectFromTransform(t,s,i,n,o){return this.Unproject(t,s,i,n,o,y.IdentityReadOnly)}static Unproject(t,s,i,n,o,r){const e=new h;return h.UnprojectToRef(t,s,i,n,o,r,e),e}static UnprojectToRef(t,s,i,n,o,r,e){return h.UnprojectFloatsToRef(t._x,t._y,t._z,s,i,n,o,r,e),e}static UnprojectFloatsToRef(t,s,i,n,o,r,e,a,_){const c=R.Matrix[0];r.multiplyToRef(e,c),c.multiplyToRef(a,c),c.invert();const m=R.Vector3[0];return m.x=t/n*2-1,m.y=-(s/o*2-1),rt.LastCreatedEngine?.isNDCHalfZRange?m.z=i:m.z=2*i-1,h.TransformCoordinatesToRef(m,c,_),_}static Minimize(t,s){const i=new h;return i.copyFrom(t),i.minimizeInPlace(s),i}static Maximize(t,s){const i=new h;return i.copyFrom(t),i.maximizeInPlace(s),i}static Distance(t,s){return Math.sqrt(h.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t._x-s._x,n=t._y-s._y,o=t._z-s._z;return i*i+n*n+o*o}static ProjectOnTriangleToRef(t,s,i,n,o){const r=R.Vector3[0],e=R.Vector3[1],a=R.Vector3[2],_=R.Vector3[3],c=R.Vector3[4];i.subtractToRef(s,r),n.subtractToRef(s,e),n.subtractToRef(i,a);const m=r.length(),x=e.length(),w=a.length();if(m<U||x<U||w<U)return o.copyFrom(s),h.Distance(t,s);t.subtractToRef(s,c),h.CrossToRef(r,e,_);const f=_.length();if(f<U)return o.copyFrom(s),h.Distance(t,s);_.normalizeFromLength(f);let F=c.length();if(F<U)return o.copyFrom(s),0;c.normalizeFromLength(F);const I=h.Dot(_,c),p=R.Vector3[5],d=R.Vector3[6];p.copyFrom(_).scaleInPlace(-F*I),d.copyFrom(t).addInPlace(p);const L=R.Vector3[4],l=R.Vector3[5],k=R.Vector3[7],A=R.Vector3[8];L.copyFrom(r).scaleInPlace(1/m),A.copyFrom(e).scaleInPlace(1/x),L.addInPlace(A).scaleInPlace(-1),l.copyFrom(r).scaleInPlace(-1/m),A.copyFrom(a).scaleInPlace(1/w),l.addInPlace(A).scaleInPlace(-1),k.copyFrom(a).scaleInPlace(-1/w),A.copyFrom(e).scaleInPlace(-1/x),k.addInPlace(A).scaleInPlace(-1);const C=R.Vector3[9];let g;C.copyFrom(d).subtractInPlace(s),h.CrossToRef(L,C,A),g=h.Dot(A,_);const N=g;C.copyFrom(d).subtractInPlace(i),h.CrossToRef(l,C,A),g=h.Dot(A,_);const q=g;C.copyFrom(d).subtractInPlace(n),h.CrossToRef(k,C,A),g=h.Dot(A,_);const E=g,H=R.Vector3[10];let O,M;N>0&&q<0?(H.copyFrom(r),O=s,M=i):q>0&&E<0?(H.copyFrom(a),O=i,M=n):(H.copyFrom(e).scaleInPlace(-1),O=n,M=s);const X=R.Vector3[9],Y=R.Vector3[4];if(O.subtractToRef(d,A),M.subtractToRef(d,X),h.CrossToRef(A,X,Y),!(h.Dot(Y,_)<0))return o.copyFrom(d),Math.abs(F*I);const Z=R.Vector3[5];h.CrossToRef(H,Y,Z),Z.normalize();const B=R.Vector3[9];B.copyFrom(O).subtractInPlace(d);const j=B.length();if(j<U)return o.copyFrom(O),h.Distance(t,O);B.normalizeFromLength(j);const W=h.Dot(Z,B),K=R.Vector3[7];K.copyFrom(d).addInPlace(Z.scaleInPlace(j*W)),A.copyFrom(K).subtractInPlace(O),F=H.length(),H.normalizeFromLength(F);let V=h.Dot(A,H)/Math.max(F,U);return V=b(V,0,1),K.copyFrom(O).addInPlace(H.scaleInPlace(V*F)),o.copyFrom(K),h.Distance(t,K)}static Center(t,s){return h.CenterToRef(t,s,h.Zero())}static CenterToRef(t,s,i){return i.copyFromFloats((t._x+s._x)/2,(t._y+s._y)/2,(t._z+s._z)/2)}static RotationFromAxis(t,s,i){const n=new h;return h.RotationFromAxisToRef(t,s,i,n),n}static RotationFromAxisToRef(t,s,i,n){const o=R.Quaternion[0];return z.RotationQuaternionFromAxisToRef(t,s,i,o),o.toEulerAnglesToRef(n),n}}h._V8PerformanceHack=new h(.5,.5,.5);h._UpReadOnly=h.Up();h._DownReadOnly=h.Down();h._LeftHandedForwardReadOnly=h.Forward(!1);h._RightHandedForwardReadOnly=h.Forward(!0);h._LeftHandedBackwardReadOnly=h.Backward(!1);h._RightHandedBackwardReadOnly=h.Backward(!0);h._RightReadOnly=h.Right();h._LeftReadOnly=h.Left();h._ZeroReadOnly=h.Zero();h._OneReadOnly=h.One();Object.defineProperties(h.prototype,{dimension:{value:[3]},rank:{value:1}});class u{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(t=0,s=0,i=0,n=0){this._isDirty=!0,this._x=t,this._y=s,this._z=i,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){const t=S(this._x),s=S(this._y),i=S(this._z),n=S(this._w);let o=t;return o=o*397^s,o=o*397^i,o=o*397^n,o}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t,s){return s===void 0&&(s=0),t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,this}fromArray(t,s=0){return u.FromArrayToRef(t,s,this),this}addInPlace(t){return this.x+=t._x,this.y+=t._y,this.z+=t._z,this.w+=t._w,this}addInPlaceFromFloats(t,s,i,n){return this.x+=t,this.y+=s,this.z+=i,this.w+=n,this}add(t){return new u(this._x+t.x,this._y+t.y,this._z+t.z,this._w+t.w)}addToRef(t,s){return s.x=this._x+t.x,s.y=this._y+t.y,s.z=this._z+t.z,s.w=this._w+t.w,s}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subtract(t){return new u(this._x-t.x,this._y-t.y,this._z-t.z,this._w-t.w)}subtractToRef(t,s){return s.x=this._x-t.x,s.y=this._y-t.y,s.z=this._z-t.z,s.w=this._w-t.w,s}subtractFromFloats(t,s,i,n){return new u(this._x-t,this._y-s,this._z-i,this._w-n)}subtractFromFloatsToRef(t,s,i,n,o){return o.x=this._x-t,o.y=this._y-s,o.z=this._z-i,o.w=this._w-n,o}negate(){return new u(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.x=-this._x,t.y=-this._y,t.z=-this._z,t.w=-this._w,t}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new u(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,s){return s.x=this._x*t,s.y=this._y*t,s.z=this._z*t,s.w=this._w*t,s}scaleAndAddToRef(t,s){return s.x+=this._x*t,s.y+=this._y*t,s.z+=this._z*t,s.w+=this._w*t,s}equals(t){return t&&this._x===t.x&&this._y===t.y&&this._z===t.z&&this._w===t.w}equalsWithEpsilon(t,s=U){return t&&D(this._x,t.x,s)&&D(this._y,t.y,s)&&D(this._z,t.z,s)&&D(this._w,t.w,s)}equalsToFloats(t,s,i,n){return this._x===t&&this._y===s&&this._z===i&&this._w===n}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new u(this._x*t.x,this._y*t.y,this._z*t.z,this._w*t.w)}multiplyToRef(t,s){return s.x=this._x*t.x,s.y=this._y*t.y,s.z=this._z*t.z,s.w=this._w*t.w,s}multiplyByFloats(t,s,i,n){return new u(this._x*t,this._y*s,this._z*i,this._w*n)}divide(t){return new u(this._x/t.x,this._y/t.y,this._z/t.z,this._w/t.w)}divideToRef(t,s){return s.x=this._x/t.x,s.y=this._y/t.y,s.z=this._z/t.z,s.w=this._w/t.w,s}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this._x&&(this.x=t.x),t.y<this._y&&(this.y=t.y),t.z<this._z&&(this.z=t.z),t.w<this._w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this._x&&(this.x=t.x),t.y>this._y&&(this.y=t.y),t.z>this._z&&(this.z=t.z),t.w>this._w&&(this.w=t.w),this}minimizeInPlaceFromFloats(t,s,i,n){return this.x=Math.min(t,this._x),this.y=Math.min(s,this._y),this.z=Math.min(i,this._z),this.w=Math.min(n,this._w),this}maximizeInPlaceFromFloats(t,s,i,n){return this.x=Math.max(t,this._x),this.y=Math.max(s,this._y),this.z=Math.max(i,this._z),this.w=Math.max(n,this._w),this}floorToRef(t){return t.x=Math.floor(this._x),t.y=Math.floor(this._y),t.z=Math.floor(this._z),t.w=Math.floor(this._w),t}floor(){return new u(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(t){return t.x=this._x-Math.floor(this._x),t.y=this._y-Math.floor(this._y),t.z=this._z-Math.floor(this._z),t.w=this._w-Math.floor(this._w),t}fract(){return new u(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new u)}normalizeToRef(t){const s=this.length();return s===0||s===1?(t.x=this._x,t.y=this._y,t.z=this._z,t.w=this._w,t):this.scaleToRef(1/s,t)}toVector3(){return new h(this._x,this._y,this._z)}clone(){return new u(this._x,this._y,this._z,this._w)}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}copyFromFloats(t,s,i,n){return this.x=t,this.y=s,this.z=i,this.w=n,this}set(t,s,i,n){return this.copyFromFloats(t,s,i,n)}setAll(t){return this.x=this.y=this.z=this.w=t,this}dot(t){return this._x*t.x+this._y*t.y+this._z*t.z+this._w*t.w}static FromArray(t,s){return s||(s=0),new u(t[s],t[s+1],t[s+2],t[s+3])}static FromArrayToRef(t,s,i){return i.x=t[s],i.y=t[s+1],i.z=t[s+2],i.w=t[s+3],i}static FromFloatArrayToRef(t,s,i){return u.FromArrayToRef(t,s,i),i}static FromFloatsToRef(t,s,i,n,o){return o.x=t,o.y=s,o.z=i,o.w=n,o}static Zero(){return new u(0,0,0,0)}static One(){return new u(1,1,1,1)}static Random(t=0,s=1){return new u(P(t,s),P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.x=P(t,s),i.y=P(t,s),i.z=P(t,s),i.w=P(t,s),i}static Clamp(t,s,i){return u.ClampToRef(t,s,i,new u)}static ClampToRef(t,s,i,n){return n.x=b(t.x,s.x,i.x),n.y=b(t.y,s.y,i.y),n.z=b(t.z,s.z,i.z),n.w=b(t.w,s.w,i.w),n}static CheckExtends(t,s,i){s.minimizeInPlace(t),i.maximizeInPlace(t)}static get ZeroReadOnly(){return u._ZeroReadOnly}static Normalize(t){return u.NormalizeToRef(t,new u)}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Minimize(t,s){const i=new u;return i.copyFrom(t),i.minimizeInPlace(s),i}static Maximize(t,s){const i=new u;return i.copyFrom(t),i.maximizeInPlace(s),i}static Distance(t,s){return Math.sqrt(u.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y,o=t.z-s.z,r=t.w-s.w;return i*i+n*n+o*o+r*r}static Center(t,s){return u.CenterToRef(t,s,new u)}static CenterToRef(t,s,i){return i.x=(t.x+s.x)/2,i.y=(t.y+s.y)/2,i.z=(t.z+s.z)/2,i.w=(t.w+s.w)/2,i}static TransformCoordinates(t,s){return u.TransformCoordinatesToRef(t,s,new u)}static TransformCoordinatesToRef(t,s,i){return u.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,s,i),i}static TransformCoordinatesFromFloatsToRef(t,s,i,n,o){const r=n.m,e=t*r[0]+s*r[4]+i*r[8]+r[12],a=t*r[1]+s*r[5]+i*r[9]+r[13],_=t*r[2]+s*r[6]+i*r[10]+r[14],c=t*r[3]+s*r[7]+i*r[11]+r[15];return o.x=e,o.y=a,o.z=_,o.w=c,o}static TransformNormal(t,s){return u.TransformNormalToRef(t,s,new u)}static TransformNormalToRef(t,s,i){const n=s.m,o=t.x*n[0]+t.y*n[4]+t.z*n[8],r=t.x*n[1]+t.y*n[5]+t.z*n[9],e=t.x*n[2]+t.y*n[6]+t.z*n[10];return i.x=o,i.y=r,i.z=e,i.w=t.w,i}static TransformNormalFromFloatsToRef(t,s,i,n,o,r){const e=o.m;return r.x=t*e[0]+s*e[4]+i*e[8],r.y=t*e[1]+s*e[5]+i*e[9],r.z=t*e[2]+s*e[6]+i*e[10],r.w=n,r}static FromVector3(t,s=0){return new u(t._x,t._y,t._z,s)}static Dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}}u._V8PerformanceHack=new u(.5,.5,.5,.5);u._ZeroReadOnly=u.Zero();Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class z{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(t=0,s=0,i=0,n=1){this._isDirty=!0,this._x=t,this._y=s,this._z=i,this._w=n}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const t=S(this._x),s=S(this._y),i=S(this._z),n=S(this._w);let o=t;return o=o*397^s,o=o*397^i,o=o*397^n,o}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t,s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,this}fromArray(t,s=0){return z.FromArrayToRef(t,s,this)}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t,s=U){return t&&D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)&&D(this._w,t._w,s)}isApprox(t,s=U){return t&&(D(this._x,t._x,s)&&D(this._y,t._y,s)&&D(this._z,t._z,s)&&D(this._w,t._w,s)||D(this._x,-t._x,s)&&D(this._y,-t._y,s)&&D(this._z,-t._z,s)&&D(this._w,-t._w,s))}clone(){return new z(this._x,this._y,this._z,this._w)}copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}copyFromFloats(t,s,i,n){return this._x=t,this._y=s,this._z=i,this._w=n,this._isDirty=!0,this}set(t,s,i,n){return this.copyFromFloats(t,s,i,n)}setAll(t){return this.copyFromFloats(t,t,t,t)}add(t){return new z(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}addToRef(t,s){return s._x=this._x+t._x,s._y=this._y+t._y,s._z=this._z+t._z,s._w=this._w+t._w,s._isDirty=!0,s}addInPlaceFromFloats(t,s,i,n){return this._x+=t,this._y+=s,this._z+=i,this._w+=n,this._isDirty=!0,this}subtractToRef(t,s){return s._x=this._x-t._x,s._y=this._y-t._y,s._z=this._z-t._z,s._w=this._w-t._w,s._isDirty=!0,s}subtractFromFloats(t,s,i,n){return this.subtractFromFloatsToRef(t,s,i,n,new z)}subtractFromFloatsToRef(t,s,i,n,o){return o._x=this._x-t,o._y=this._y-s,o._z=this._z-i,o._w=this._w-n,o._isDirty=!0,o}subtract(t){return new z(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new z(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,s){return s._x=this._x*t,s._y=this._y*t,s._z=this._z*t,s._w=this._w*t,s._isDirty=!0,s}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,s){return s._x+=this._x*t,s._y+=this._y*t,s._z+=this._z*t,s._w+=this._w*t,s._isDirty=!0,s}multiply(t){const s=new z(0,0,0,1);return this.multiplyToRef(t,s),s}multiplyToRef(t,s){const i=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,n=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,o=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,r=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return s.copyFromFloats(i,n,o,r),s}multiplyInPlace(t){return this.multiplyToRef(t,this)}multiplyByFloats(t,s,i,n){return this._x*=t,this._y*=s,this._z*=i,this._w*=n,this._isDirty=!0,this}divide(t){throw new ReferenceError("Can not divide a quaternion")}divideToRef(t,s){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(t){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new z)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(t){return t._x=-this._x,t._y=-this._y,t._z=-this._z,t._w=-this._w,t._isDirty=!0,t}equalsToFloats(t,s,i,n){return this._x===t&&this._y===s&&this._z===i&&this._w===n}floorToRef(t){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(t){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(t){return t.copyFromFloats(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new z(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),s=this.lengthSquared();return s==0||s==1||t.scaleInPlace(1/s),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return t==0||t==1?this:(this.scaleInPlace(1/t),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return t===0||t===1?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new z(0,0,0,1);return this.normalizeToRef(t),t}normalizeToRef(t){const s=this.length();return s===0||s===1?t.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/s,t)}toEulerAngles(){const t=h.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const s=this._z,i=this._x,n=this._y,o=this._w,r=n*s-i*o,e=.4999999;if(r<-e)t._y=2*Math.atan2(n,o),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(r>e)t._y=2*Math.atan2(n,o),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const a=o*o,_=s*s,c=i*i,m=n*n;t._z=Math.atan2(2*(i*n+s*o),-_-c+m+a),t._x=Math.asin(-2*r),t._y=Math.atan2(2*(s*i+n*o),_-c-m+a),t._isDirty=!0}return t}toAlphaBetaGammaToRef(t){const s=this._z,i=this._x,n=this._y,o=this._w,r=Math.sqrt(i*i+n*n),e=Math.sqrt(s*s+o*o),a=2*Math.atan2(r,e),_=2*Math.atan2(s,o),c=2*Math.atan2(n,i),m=(_+c)/2,x=(_-c)/2;return t.set(x,a,m),t}toRotationMatrix(t){return y.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return z.FromRotationMatrixToRef(t,this),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}toAxisAngle(){const t=h.Zero(),s=this.toAxisAngleToRef(t);return{axis:t,angle:s}}toAxisAngleToRef(t){let s=0;const i=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),n=this._w;return i>0?(s=2*Math.atan2(i,n),t.set(this._x/i,this._y/i,this._z/i)):(s=0,t.set(1,0,0)),s}static FromRotationMatrix(t){const s=new z;return z.FromRotationMatrixToRef(t,s),s}static FromRotationMatrixToRef(t,s){const i=t.m,n=i[0],o=i[4],r=i[8],e=i[1],a=i[5],_=i[9],c=i[2],m=i[6],x=i[10],w=n+a+x;let f;return w>0?(f=.5/Math.sqrt(w+1),s._w=.25/f,s._x=(m-_)*f,s._y=(r-c)*f,s._z=(e-o)*f,s._isDirty=!0):n>a&&n>x?(f=2*Math.sqrt(1+n-a-x),s._w=(m-_)/f,s._x=.25*f,s._y=(o+e)/f,s._z=(r+c)/f,s._isDirty=!0):a>x?(f=2*Math.sqrt(1+a-n-x),s._w=(r-c)/f,s._x=(o+e)/f,s._y=.25*f,s._z=(_+m)/f,s._isDirty=!0):(f=2*Math.sqrt(1+x-n-a),s._w=(e-o)/f,s._x=(r+c)/f,s._y=(_+m)/f,s._z=.25*f,s._isDirty=!0),s}static Dot(t,s){return t._x*s._x+t._y*s._y+t._z*s._z+t._w*s._w}static AreClose(t,s,i=.1){const n=z.Dot(t,s);return 1-n*n<=i}static SmoothToRef(t,s,i,n,o){let r=n===0?1:i/n;return r=b(r,0,1),z.SlerpToRef(t,s,r,o),o}static Zero(){return new z(0,0,0,0)}static Inverse(t){return new z(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,s){return s.set(-t._x,-t._y,-t._z,t._w),s}static Identity(){return new z(0,0,0,1)}static IsIdentity(t){return t&&t._x===0&&t._y===0&&t._z===0&&t._w===1}static RotationAxis(t,s){return z.RotationAxisToRef(t,s,new z)}static RotationAxisToRef(t,s,i){i._w=Math.cos(s/2);const n=Math.sin(s/2)/t.length();return i._x=t._x*n,i._y=t._y*n,i._z=t._z*n,i._isDirty=!0,i}static FromArray(t,s){return s||(s=0),new z(t[s],t[s+1],t[s+2],t[s+3])}static FromArrayToRef(t,s,i){return i._x=t[s],i._y=t[s+1],i._z=t[s+2],i._w=t[s+3],i._isDirty=!0,i}static FromFloatsToRef(t,s,i,n,o){return o.copyFromFloats(t,s,i,n),o}static FromEulerAngles(t,s,i){const n=new z;return z.RotationYawPitchRollToRef(s,t,i,n),n}static FromEulerAnglesToRef(t,s,i,n){return z.RotationYawPitchRollToRef(s,t,i,n),n}static FromEulerVector(t){const s=new z;return z.RotationYawPitchRollToRef(t._y,t._x,t._z,s),s}static FromEulerVectorToRef(t,s){return z.RotationYawPitchRollToRef(t._y,t._x,t._z,s),s}static FromUnitVectorsToRef(t,s,i,n=U){const o=h.Dot(t,s)+1;return o<n?Math.abs(t.x)>Math.abs(t.z)?i.set(-t.y,t.x,0,0):i.set(0,-t.z,t.y,0):(h.CrossToRef(t,s,$.Vector3[0]),i.set($.Vector3[0].x,$.Vector3[0].y,$.Vector3[0].z,o)),i.normalize()}static RotationYawPitchRoll(t,s,i){const n=new z;return z.RotationYawPitchRollToRef(t,s,i,n),n}static RotationYawPitchRollToRef(t,s,i,n){const o=i*.5,r=s*.5,e=t*.5,a=Math.sin(o),_=Math.cos(o),c=Math.sin(r),m=Math.cos(r),x=Math.sin(e),w=Math.cos(e);return n._x=w*c*_+x*m*a,n._y=x*m*_-w*c*a,n._z=w*m*a-x*c*_,n._w=w*m*_+x*c*a,n._isDirty=!0,n}static RotationAlphaBetaGamma(t,s,i){const n=new z;return z.RotationAlphaBetaGammaToRef(t,s,i,n),n}static RotationAlphaBetaGammaToRef(t,s,i,n){const o=(i+t)*.5,r=(i-t)*.5,e=s*.5;return n._x=Math.cos(r)*Math.sin(e),n._y=Math.sin(r)*Math.sin(e),n._z=Math.sin(o)*Math.cos(e),n._w=Math.cos(o)*Math.cos(e),n._isDirty=!0,n}static RotationQuaternionFromAxis(t,s,i){const n=new z(0,0,0,0);return z.RotationQuaternionFromAxisToRef(t,s,i,n),n}static RotationQuaternionFromAxisToRef(t,s,i,n){const o=R.Matrix[0];return t=t.normalizeToRef(R.Vector3[0]),s=s.normalizeToRef(R.Vector3[1]),i=i.normalizeToRef(R.Vector3[2]),y.FromXYZAxesToRef(t,s,i,o),z.FromRotationMatrixToRef(o,n),n}static FromLookDirectionLH(t,s){const i=new z;return z.FromLookDirectionLHToRef(t,s,i),i}static FromLookDirectionLHToRef(t,s,i){const n=R.Matrix[0];return y.LookDirectionLHToRef(t,s,n),z.FromRotationMatrixToRef(n,i),i}static FromLookDirectionRH(t,s){const i=new z;return z.FromLookDirectionRHToRef(t,s,i),i}static FromLookDirectionRHToRef(t,s,i){const n=R.Matrix[0];return y.LookDirectionRHToRef(t,s,n),z.FromRotationMatrixToRef(n,i)}static Slerp(t,s,i){const n=z.Identity();return z.SlerpToRef(t,s,i,n),n}static SlerpToRef(t,s,i,n){let o,r,e=t._x*s._x+t._y*s._y+t._z*s._z+t._w*s._w,a=!1;if(e<0&&(a=!0,e=-e),e>.999999)r=1-i,o=a?-i:i;else{const _=Math.acos(e),c=1/Math.sin(_);r=Math.sin((1-i)*_)*c,o=a?-Math.sin(i*_)*c:Math.sin(i*_)*c}return n._x=r*t._x+o*s._x,n._y=r*t._y+o*s._y,n._z=r*t._z+o*s._z,n._w=r*t._w+o*s._w,n._isDirty=!0,n}static Hermite(t,s,i,n,o){const r=o*o,e=o*r,a=2*e-3*r+1,_=-2*e+3*r,c=e-2*r+o,m=e-r,x=t._x*a+i._x*_+s._x*c+n._x*m,w=t._y*a+i._y*_+s._y*c+n._y*m,f=t._z*a+i._z*_+s._z*c+n._z*m,F=t._w*a+i._w*_+s._w*c+n._w*m;return new z(x,w,f,F)}static Hermite1stDerivative(t,s,i,n,o){const r=new z;return this.Hermite1stDerivativeToRef(t,s,i,n,o,r),r}static Hermite1stDerivativeToRef(t,s,i,n,o,r){const e=o*o;return r._x=(e-o)*6*t._x+(3*e-4*o+1)*s._x+(-e+o)*6*i._x+(3*e-2*o)*n._x,r._y=(e-o)*6*t._y+(3*e-4*o+1)*s._y+(-e+o)*6*i._y+(3*e-2*o)*n._y,r._z=(e-o)*6*t._z+(3*e-4*o+1)*s._z+(-e+o)*6*i._z+(3*e-2*o)*n._z,r._w=(e-o)*6*t._w+(3*e-4*o+1)*s._w+(-e+o)*6*i._w+(3*e-2*o)*n._w,r._isDirty=!0,r}static Normalize(t){const s=z.Zero();return z.NormalizeToRef(t,s),s}static NormalizeToRef(t,s){return t.normalizeToRef(s),s}static Clamp(t,s,i){const n=new z;return z.ClampToRef(t,s,i,n),n}static ClampToRef(t,s,i,n){return n.copyFromFloats(b(t.x,s.x,i.x),b(t.y,s.y,i.y),b(t.z,s.z,i.z),b(t.w,s.w,i.w))}static Random(t=0,s=1){return new z(P(t,s),P(t,s),P(t,s),P(t,s))}static RandomToRef(t=0,s=1,i){return i.copyFromFloats(P(t,s),P(t,s),P(t,s),P(t,s))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(t,s){return Math.sqrt(z.DistanceSquared(t,s))}static DistanceSquared(t,s){const i=t.x-s.x,n=t.y-s.y,o=t.z-s.z,r=t.w-s.w;return i*i+n*n+o*o+r*r}static Center(t,s){return z.CenterToRef(t,s,z.Zero())}static CenterToRef(t,s,i){return i.copyFromFloats((t.x+s.x)/2,(t.y+s.y)/2,(t.z+s.z)/2,(t.w+s.w)/2)}}z._V8PerformanceHack=new z(.5,.5,.5,.5);Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class y{static get Use64Bits(){return tt.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=et._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t,s=!1,i=!1,n=!0){this._isIdentity=t,this._isIdentity3x2=t||i,this._isIdentityDirty=this._isIdentity?!1:s,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:n}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,tt.MatrixTrackPrecisionChange&&tt.MatrixTrackedMatrices.push(this),this._m=new tt.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this._m;this._isIdentity=t[0]===1&&t[1]===0&&t[2]===0&&t[3]===0&&t[4]===0&&t[5]===1&&t[6]===0&&t[7]===0&&t[8]===0&&t[9]===0&&t[10]===1&&t[11]===0&&t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const t=this._m,s=t[0],i=t[1],n=t[2],o=t[3],r=t[4],e=t[5],a=t[6],_=t[7],c=t[8],m=t[9],x=t[10],w=t[11],f=t[12],F=t[13],I=t[14],p=t[15],d=x*p-I*w,L=m*p-F*w,l=m*I-F*x,k=c*p-f*w,A=c*I-x*f,C=c*F-f*m,g=+(e*d-a*L+_*l),N=-(r*d-a*k+_*A),q=+(r*L-e*k+_*C),E=-(r*l-e*A+a*C);return s*g+i*N+n*q+o*E}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(t=null,s=0){if(!t)return this._m;const i=this._m;for(let n=0;n<16;n++)t[s+n]=i[n];return this}asArray(){return this._m}fromArray(t,s=0){return y.FromArrayToRef(t,s,this)}copyFromFloats(...t){return y.FromArrayToRef(t,0,this)}set(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=t[i];return this.markAsUpdated(),this}setAll(t){const s=this._m;for(let i=0;i<16;i++)s[i]=t;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return y.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const s=new y;return this.addToRef(t,s),s}addToRef(t,s){const i=this._m,n=s._m,o=t.m;for(let r=0;r<16;r++)n[r]=i[r]+o[r];return s.markAsUpdated(),s}addToSelf(t){const s=this._m,i=t.m;return s[0]+=i[0],s[1]+=i[1],s[2]+=i[2],s[3]+=i[3],s[4]+=i[4],s[5]+=i[5],s[6]+=i[6],s[7]+=i[7],s[8]+=i[8],s[9]+=i[9],s[10]+=i[10],s[11]+=i[11],s[12]+=i[12],s[13]+=i[13],s[14]+=i[14],s[15]+=i[15],this.markAsUpdated(),this}addInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]+=i[n];return this.markAsUpdated(),this}addInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]+=t[i];return this.markAsUpdated(),this}subtract(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]-=i[n];return this.markAsUpdated(),this}subtractToRef(t,s){const i=this._m,n=t.m,o=s._m;for(let r=0;r<16;r++)o[r]=i[r]-n[r];return s.markAsUpdated(),s}subtractInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]-=i[n];return this.markAsUpdated(),this}subtractFromFloats(...t){return this.subtractFromFloatsToRef(...t,new y)}subtractFromFloatsToRef(...t){const s=t.pop(),i=this._m,n=s._m,o=t;for(let r=0;r<16;r++)n[r]=i[r]-o[r];return s.markAsUpdated(),s}invertToRef(t){return this._isIdentity===!0?(y.IdentityToRef(t),t):(pt(this,t.asArray())?t.markAsUpdated():t.copyFrom(this),t)}addAtIndex(t,s){return this._m[t]+=s,this.markAsUpdated(),this}multiplyAtIndex(t,s){return this._m[t]*=s,this.markAsUpdated(),this}setTranslationFromFloats(t,s,i){return this._m[12]=t,this._m[13]=s,this._m[14]=i,this.markAsUpdated(),this}addTranslationFromFloats(t,s,i){return this._m[12]+=t,this._m[13]+=s,this._m[14]+=i,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new h(this._m[12],this._m[13],this._m[14])}getTranslationToRef(t){return t.x=this._m[12],t.y=this._m[13],t.z=this._m[14],t}removeRotationAndScaling(){const t=this.m;return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(t[12]===0&&t[13]===0&&t[14]===0&&t[15]===1),this}copyFrom(t){t.copyToArray(this._m);const s=t;return this.updateFlag=s.updateFlag,this._updateIdentityStatus(s._isIdentity,s._isIdentityDirty,s._isIdentity3x2,s._isIdentity3x2Dirty),this}copyToArray(t,s=0){return lt(this,t,s),this}multiply(t){const s=new y;return this.multiplyToRef(t,s),s}multiplyInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]*=i[n];return this.markAsUpdated(),this}multiplyByFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]*=t[i];return this.markAsUpdated(),this}multiplyByFloatsToRef(...t){const s=t.pop(),i=this._m,n=s._m,o=t;for(let r=0;r<16;r++)n[r]=i[r]*o[r];return s.markAsUpdated(),s}multiplyToRef(t,s){return this._isIdentity?(s.copyFrom(t),s):t._isIdentity?(s.copyFrom(this),s):(this.multiplyToArray(t,s._m,0),s.markAsUpdated(),s)}multiplyToArray(t,s,i){return Ft(this,t,s,i),this}divide(t){return this.divideToRef(t,new y)}divideToRef(t,s){const i=this._m,n=t.m,o=s._m;for(let r=0;r<16;r++)o[r]=i[r]/n[r];return s.markAsUpdated(),s}divideInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]/=i[n];return this.markAsUpdated(),this}minimizeInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]=Math.min(s[n],i[n]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=Math.min(s[i],t[i]);return this.markAsUpdated(),this}maximizeInPlace(t){const s=this._m,i=t.m;for(let n=0;n<16;n++)s[n]=Math.min(s[n],i[n]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(...t){const s=this._m;for(let i=0;i<16;i++)s[i]=Math.min(s[i],t[i]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new y)}negateInPlace(){const t=this._m;for(let s=0;s<16;s++)t[s]=-t[s];return this.markAsUpdated(),this}negateToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=-s[n];return t.markAsUpdated(),t}equals(t){const s=t;if(!s)return!1;if((this._isIdentity||s._isIdentity)&&!this._isIdentityDirty&&!s._isIdentityDirty)return this._isIdentity&&s._isIdentity;const i=this.m,n=s.m;return i[0]===n[0]&&i[1]===n[1]&&i[2]===n[2]&&i[3]===n[3]&&i[4]===n[4]&&i[5]===n[5]&&i[6]===n[6]&&i[7]===n[7]&&i[8]===n[8]&&i[9]===n[9]&&i[10]===n[10]&&i[11]===n[11]&&i[12]===n[12]&&i[13]===n[13]&&i[14]===n[14]&&i[15]===n[15]}equalsWithEpsilon(t,s=0){const i=this._m,n=t.m;for(let o=0;o<16;o++)if(!D(i[o],n[o],s))return!1;return!0}equalsToFloats(...t){const s=this._m;for(let i=0;i<16;i++)if(s[i]!=t[i])return!1;return!0}floor(){return this.floorToRef(new y)}floorToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=Math.floor(s[n]);return t.markAsUpdated(),t}fract(){return this.fractToRef(new y)}fractToRef(t){const s=this._m,i=t._m;for(let n=0;n<16;n++)i[n]=s[n]-Math.floor(s[n]);return t.markAsUpdated(),t}clone(){const t=new y;return t.copyFrom(this),t}getClassName(){return"Matrix"}getHashCode(){let t=S(this._m[0]);for(let s=1;s<16;s++)t=t*397^S(this._m[s]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new z,this.decompose(t.scaling,t.rotationQuaternion,t.position)}decompose(t,s,i,n,o=!0){if(this._isIdentity)return i&&i.setAll(0),t&&t.setAll(1),s&&s.copyFromFloats(0,0,0,1),!0;const r=this._m;if(i&&i.copyFromFloats(r[12],r[13],r[14]),t=t||R.Vector3[0],t.x=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]),t.y=Math.sqrt(r[4]*r[4]+r[5]*r[5]+r[6]*r[6]),t.z=Math.sqrt(r[8]*r[8]+r[9]*r[9]+r[10]*r[10]),n){const e=(o?n.absoluteScaling.x:n.scaling.x)<0?-1:1,a=(o?n.absoluteScaling.y:n.scaling.y)<0?-1:1,_=(o?n.absoluteScaling.z:n.scaling.z)<0?-1:1;t.x*=e,t.y*=a,t.z*=_}else this.determinant()<=0&&(t.y*=-1);if(t._x===0||t._y===0||t._z===0)return s&&s.copyFromFloats(0,0,0,1),!1;if(s){const e=1/t._x,a=1/t._y,_=1/t._z;y.FromValuesToRef(r[0]*e,r[1]*e,r[2]*e,0,r[4]*a,r[5]*a,r[6]*a,0,r[8]*_,r[9]*_,r[10]*_,0,0,0,0,1,R.Matrix[0]),z.FromRotationMatrixToRef(R.Matrix[0],s)}return!0}getRow(t){if(t<0||t>3)return null;const s=t*4;return new u(this._m[s+0],this._m[s+1],this._m[s+2],this._m[s+3])}getRowToRef(t,s){if(t>=0&&t<=3){const i=t*4;s.x=this._m[i+0],s.y=this._m[i+1],s.z=this._m[i+2],s.w=this._m[i+3]}return s}setRow(t,s){return this.setRowFromFloats(t,s.x,s.y,s.z,s.w)}transpose(){const t=new y;return y.TransposeToRef(this,t),t}transposeToRef(t){return y.TransposeToRef(this,t),t}setRowFromFloats(t,s,i,n,o){if(t<0||t>3)return this;const r=t*4;return this._m[r+0]=s,this._m[r+1]=i,this._m[r+2]=n,this._m[r+3]=o,this.markAsUpdated(),this}scale(t){const s=new y;return this.scaleToRef(t,s),s}scaleToRef(t,s){for(let i=0;i<16;i++)s._m[i]=this._m[i]*t;return s.markAsUpdated(),s}scaleAndAddToRef(t,s){for(let i=0;i<16;i++)s._m[i]+=this._m[i]*t;return s.markAsUpdated(),s}scaleInPlace(t){const s=this._m;for(let i=0;i<16;i++)s[i]*=t;return this.markAsUpdated(),this}toNormalMatrix(t){const s=R.Matrix[0];this.invertToRef(s),s.transposeToRef(t);const i=t._m;return y.FromValuesToRef(i[0],i[1],i[2],0,i[4],i[5],i[6],0,i[8],i[9],i[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new y;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const s=R.Vector3[0];if(!this.decompose(s))return y.IdentityToRef(t),t;const i=this._m,n=1/s._x,o=1/s._y,r=1/s._z;return y.FromValuesToRef(i[0]*n,i[1]*n,i[2]*n,0,i[4]*o,i[5]*o,i[6]*o,0,i[8]*r,i[9]*r,i[10]*r,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this._m;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this._m;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static FromArray(t,s=0){const i=new y;return y.FromArrayToRef(t,s,i),i}static FromArrayToRef(t,s,i){for(let n=0;n<16;n++)i._m[n]=t[n+s];return i.markAsUpdated(),i}static FromFloat32ArrayToRefScaled(t,s,i,n){return n._m[0]=t[0+s]*i,n._m[1]=t[1+s]*i,n._m[2]=t[2+s]*i,n._m[3]=t[3+s]*i,n._m[4]=t[4+s]*i,n._m[5]=t[5+s]*i,n._m[6]=t[6+s]*i,n._m[7]=t[7+s]*i,n._m[8]=t[8+s]*i,n._m[9]=t[9+s]*i,n._m[10]=t[10+s]*i,n._m[11]=t[11+s]*i,n._m[12]=t[12+s]*i,n._m[13]=t[13+s]*i,n._m[14]=t[14+s]*i,n._m[15]=t[15+s]*i,n.markAsUpdated(),n}static get IdentityReadOnly(){return y._IdentityReadOnly}static FromValuesToRef(t,s,i,n,o,r,e,a,_,c,m,x,w,f,F,I,p){const d=p._m;d[0]=t,d[1]=s,d[2]=i,d[3]=n,d[4]=o,d[5]=r,d[6]=e,d[7]=a,d[8]=_,d[9]=c,d[10]=m,d[11]=x,d[12]=w,d[13]=f,d[14]=F,d[15]=I,p.markAsUpdated()}static FromValues(t,s,i,n,o,r,e,a,_,c,m,x,w,f,F,I){const p=new y,d=p._m;return d[0]=t,d[1]=s,d[2]=i,d[3]=n,d[4]=o,d[5]=r,d[6]=e,d[7]=a,d[8]=_,d[9]=c,d[10]=m,d[11]=x,d[12]=w,d[13]=f,d[14]=F,d[15]=I,p.markAsUpdated(),p}static Compose(t,s,i){const n=new y;return y.ComposeToRef(t,s,i,n),n}static ComposeToRef(t,s,i,n){const o=n._m,r=s._x,e=s._y,a=s._z,_=s._w,c=r+r,m=e+e,x=a+a,w=r*c,f=r*m,F=r*x,I=e*m,p=e*x,d=a*x,L=_*c,l=_*m,k=_*x,A=t._x,C=t._y,g=t._z;return o[0]=(1-(I+d))*A,o[1]=(f+k)*A,o[2]=(F-l)*A,o[3]=0,o[4]=(f-k)*C,o[5]=(1-(w+d))*C,o[6]=(p+L)*C,o[7]=0,o[8]=(F+l)*g,o[9]=(p-L)*g,o[10]=(1-(w+I))*g,o[11]=0,o[12]=i._x,o[13]=i._y,o[14]=i._z,o[15]=1,n.markAsUpdated(),n}static Identity(){const t=y.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=y.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const s=new y;return y.RotationXToRef(t,s),s}static Invert(t){const s=new y;return t.invertToRef(s),s}static RotationXToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(1,0,0,0,0,n,i,0,0,-i,n,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationY(t){const s=new y;return y.RotationYToRef(t,s),s}static RotationYToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(n,0,-i,0,0,1,0,0,i,0,n,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationZ(t){const s=new y;return y.RotationZToRef(t,s),s}static RotationZToRef(t,s){const i=Math.sin(t),n=Math.cos(t);return y.FromValuesToRef(n,i,0,0,-i,n,0,0,0,0,1,0,0,0,0,1,s),s._updateIdentityStatus(n===1&&i===0),s}static RotationAxis(t,s){const i=new y;return y.RotationAxisToRef(t,s,i),i}static RotationAxisToRef(t,s,i){const n=Math.sin(-s),o=Math.cos(-s),r=1-o;t=t.normalizeToRef(R.Vector3[0]);const e=i._m;return e[0]=t._x*t._x*r+o,e[1]=t._x*t._y*r-t._z*n,e[2]=t._x*t._z*r+t._y*n,e[3]=0,e[4]=t._y*t._x*r+t._z*n,e[5]=t._y*t._y*r+o,e[6]=t._y*t._z*r-t._x*n,e[7]=0,e[8]=t._z*t._x*r-t._y*n,e[9]=t._z*t._y*r+t._x*n,e[10]=t._z*t._z*r+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,i.markAsUpdated(),i}static RotationAlignToRef(t,s,i,n=!1){const o=h.Dot(s,t),r=i._m;if(o<-1+U)r[0]=-1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=n?1:-1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=n?-1:1,r[11]=0;else{const e=h.Cross(s,t),a=1/(1+o);r[0]=e._x*e._x*a+o,r[1]=e._y*e._x*a-e._z,r[2]=e._z*e._x*a+e._y,r[3]=0,r[4]=e._x*e._y*a+e._z,r[5]=e._y*e._y*a+o,r[6]=e._z*e._y*a-e._x,r[7]=0,r[8]=e._x*e._z*a-e._y,r[9]=e._y*e._z*a+e._x,r[10]=e._z*e._z*a+o,r[11]=0}return r[12]=0,r[13]=0,r[14]=0,r[15]=1,i.markAsUpdated(),i}static RotationYawPitchRoll(t,s,i){const n=new y;return y.RotationYawPitchRollToRef(t,s,i,n),n}static RotationYawPitchRollToRef(t,s,i,n){return z.RotationYawPitchRollToRef(t,s,i,R.Quaternion[0]),R.Quaternion[0].toRotationMatrix(n),n}static Scaling(t,s,i){const n=new y;return y.ScalingToRef(t,s,i,n),n}static ScalingToRef(t,s,i,n){return y.FromValuesToRef(t,0,0,0,0,s,0,0,0,0,i,0,0,0,0,1,n),n._updateIdentityStatus(t===1&&s===1&&i===1),n}static Translation(t,s,i){const n=new y;return y.TranslationToRef(t,s,i,n),n}static TranslationToRef(t,s,i,n){return y.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,s,i,1,n),n._updateIdentityStatus(t===0&&s===0&&i===0),n}static Lerp(t,s,i){const n=new y;return y.LerpToRef(t,s,i,n),n}static LerpToRef(t,s,i,n){const o=n._m,r=t.m,e=s.m;for(let a=0;a<16;a++)o[a]=r[a]*(1-i)+e[a]*i;return n.markAsUpdated(),n}static DecomposeLerp(t,s,i){const n=new y;return y.DecomposeLerpToRef(t,s,i,n),n}static DecomposeLerpToRef(t,s,i,n){const o=R.Vector3[0],r=R.Quaternion[0],e=R.Vector3[1];t.decompose(o,r,e);const a=R.Vector3[2],_=R.Quaternion[1],c=R.Vector3[3];s.decompose(a,_,c);const m=R.Vector3[4];h.LerpToRef(o,a,i,m);const x=R.Quaternion[2];z.SlerpToRef(r,_,i,x);const w=R.Vector3[5];return h.LerpToRef(e,c,i,w),y.ComposeToRef(m,x,w,n),n}static LookAtLH(t,s,i){const n=new y;return y.LookAtLHToRef(t,s,i,n),n}static LookAtLHToRef(t,s,i,n){const o=R.Vector3[0],r=R.Vector3[1],e=R.Vector3[2];s.subtractToRef(t,e),e.normalize(),h.CrossToRef(i,e,o);const a=o.lengthSquared();a===0?o.x=1:o.normalizeFromLength(Math.sqrt(a)),h.CrossToRef(e,o,r),r.normalize();const _=-h.Dot(o,t),c=-h.Dot(r,t),m=-h.Dot(e,t);return y.FromValuesToRef(o._x,r._x,e._x,0,o._y,r._y,e._y,0,o._z,r._z,e._z,0,_,c,m,1,n),n}static LookAtRH(t,s,i){const n=new y;return y.LookAtRHToRef(t,s,i,n),n}static LookAtRHToRef(t,s,i,n){const o=R.Vector3[0],r=R.Vector3[1],e=R.Vector3[2];t.subtractToRef(s,e),e.normalize(),h.CrossToRef(i,e,o);const a=o.lengthSquared();a===0?o.x=1:o.normalizeFromLength(Math.sqrt(a)),h.CrossToRef(e,o,r),r.normalize();const _=-h.Dot(o,t),c=-h.Dot(r,t),m=-h.Dot(e,t);return y.FromValuesToRef(o._x,r._x,e._x,0,o._y,r._y,e._y,0,o._z,r._z,e._z,0,_,c,m,1,n),n}static LookDirectionLH(t,s){const i=new y;return y.LookDirectionLHToRef(t,s,i),i}static LookDirectionLHToRef(t,s,i){const n=R.Vector3[0];n.copyFrom(t),n.scaleInPlace(-1);const o=R.Vector3[1];return h.CrossToRef(s,n,o),y.FromValuesToRef(o._x,o._y,o._z,0,s._x,s._y,s._z,0,n._x,n._y,n._z,0,0,0,0,1,i),i}static LookDirectionRH(t,s){const i=new y;return y.LookDirectionRHToRef(t,s,i),i}static LookDirectionRHToRef(t,s,i){const n=R.Vector3[2];return h.CrossToRef(s,t,n),y.FromValuesToRef(n._x,n._y,n._z,0,s._x,s._y,s._z,0,t._x,t._y,t._z,0,0,0,0,1,i),i}static OrthoLH(t,s,i,n,o){const r=new y;return y.OrthoLHToRef(t,s,i,n,r,o),r}static OrthoLHToRef(t,s,i,n,o,r){const e=i,a=n,_=2/t,c=2/s,m=2/(a-e),x=-(a+e)/(a-e);return y.FromValuesToRef(_,0,0,0,0,c,0,0,0,0,m,0,0,0,x,1,o),r&&o.multiplyToRef(v,o),o._updateIdentityStatus(_===1&&c===1&&m===1&&x===0),o}static OrthoOffCenterLH(t,s,i,n,o,r,e){const a=new y;return y.OrthoOffCenterLHToRef(t,s,i,n,o,r,a,e),a}static OrthoOffCenterLHToRef(t,s,i,n,o,r,e,a){const _=o,c=r,m=2/(s-t),x=2/(n-i),w=2/(c-_),f=-(c+_)/(c-_),F=(t+s)/(t-s),I=(n+i)/(i-n);return y.FromValuesToRef(m,0,0,0,0,x,0,0,0,0,w,0,F,I,f,1,e),a&&e.multiplyToRef(v,e),e.markAsUpdated(),e}static ObliqueOffCenterLHToRef(t,s,i,n,o,r,e,a,_,c,m){const x=-e*Math.cos(a),w=-e*Math.sin(a);return y.TranslationToRef(0,0,-_,R.Matrix[1]),y.FromValuesToRef(1,0,0,0,0,1,0,0,x,w,1,0,0,0,0,1,R.Matrix[0]),R.Matrix[1].multiplyToRef(R.Matrix[0],R.Matrix[0]),y.TranslationToRef(0,0,_,R.Matrix[1]),R.Matrix[0].multiplyToRef(R.Matrix[1],R.Matrix[0]),y.OrthoOffCenterLHToRef(t,s,i,n,o,r,c,m),R.Matrix[0].multiplyToRef(c,c),c}static OrthoOffCenterRH(t,s,i,n,o,r,e){const a=new y;return y.OrthoOffCenterRHToRef(t,s,i,n,o,r,a,e),a}static OrthoOffCenterRHToRef(t,s,i,n,o,r,e,a){return y.OrthoOffCenterLHToRef(t,s,i,n,o,r,e,a),e._m[10]*=-1,e}static ObliqueOffCenterRHToRef(t,s,i,n,o,r,e,a,_,c,m){const x=e*Math.cos(a),w=e*Math.sin(a);return y.TranslationToRef(0,0,_,R.Matrix[1]),y.FromValuesToRef(1,0,0,0,0,1,0,0,x,w,1,0,0,0,0,1,R.Matrix[0]),R.Matrix[1].multiplyToRef(R.Matrix[0],R.Matrix[0]),y.TranslationToRef(0,0,-_,R.Matrix[1]),R.Matrix[0].multiplyToRef(R.Matrix[1],R.Matrix[0]),y.OrthoOffCenterRHToRef(t,s,i,n,o,r,c,m),R.Matrix[0].multiplyToRef(c,c),c}static PerspectiveLH(t,s,i,n,o,r=0){const e=new y,a=i,_=n,c=2*a/t,m=2*a/s,x=(_+a)/(_-a),w=-2*_*a/(_-a),f=Math.tan(r);return y.FromValuesToRef(c,0,0,0,0,m,0,f,0,0,x,1,0,0,w,0,e),o&&e.multiplyToRef(v,e),e._updateIdentityStatus(!1),e}static PerspectiveFovLH(t,s,i,n,o,r=0,e=!1){const a=new y;return y.PerspectiveFovLHToRef(t,s,i,n,a,!0,o,r,e),a}static PerspectiveFovLHToRef(t,s,i,n,o,r=!0,e,a=0,_=!1){const c=i,m=n,x=1/Math.tan(t*.5),w=r?x/s:x,f=r?x:x*s,F=_&&c===0?-1:m!==0?(m+c)/(m-c):1,I=_&&c===0?2*m:m!==0?-2*m*c/(m-c):-2*c,p=Math.tan(a);return y.FromValuesToRef(w,0,0,0,0,f,0,p,0,0,F,1,0,0,I,0,o),e&&o.multiplyToRef(v,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseLHToRef(t,s,i,n,o,r=!0,e,a=0){const _=1/Math.tan(t*.5),c=r?_/s:_,m=r?_:_*s,x=Math.tan(a);return y.FromValuesToRef(c,0,0,0,0,m,0,x,0,0,-i,1,0,0,1,0,o),e&&o.multiplyToRef(v,o),o._updateIdentityStatus(!1),o}static PerspectiveFovRH(t,s,i,n,o,r=0,e=!1){const a=new y;return y.PerspectiveFovRHToRef(t,s,i,n,a,!0,o,r,e),a}static PerspectiveFovRHToRef(t,s,i,n,o,r=!0,e,a=0,_=!1){const c=i,m=n,x=1/Math.tan(t*.5),w=r?x/s:x,f=r?x:x*s,F=_&&c===0?1:m!==0?-(m+c)/(m-c):-1,I=_&&c===0?2*m:m!==0?-2*m*c/(m-c):-2*c,p=Math.tan(a);return y.FromValuesToRef(w,0,0,0,0,f,0,p,0,0,F,-1,0,0,I,0,o),e&&o.multiplyToRef(v,o),o._updateIdentityStatus(!1),o}static PerspectiveFovReverseRHToRef(t,s,i,n,o,r=!0,e,a=0){const _=1/Math.tan(t*.5),c=r?_/s:_,m=r?_:_*s,x=Math.tan(a);return y.FromValuesToRef(c,0,0,0,0,m,0,x,0,0,-i,-1,0,0,-1,0,o),e&&o.multiplyToRef(v,o),o._updateIdentityStatus(!1),o}static GetFinalMatrix(t,s,i,n,o,r){const e=t.width,a=t.height,_=t.x,c=t.y,m=y.FromValues(e/2,0,0,0,0,-a/2,0,0,0,0,r-o,0,_+e/2,a/2+c,o,1),x=new y;return s.multiplyToRef(i,x),x.multiplyToRef(n,x),x.multiplyToRef(m,x)}static GetAsMatrix2x2(t){const s=t.m,i=[s[0],s[1],s[4],s[5]];return tt.MatrixUse64Bits?i:new Float32Array(i)}static GetAsMatrix3x3(t){const s=t.m,i=[s[0],s[1],s[2],s[4],s[5],s[6],s[8],s[9],s[10]];return tt.MatrixUse64Bits?i:new Float32Array(i)}static Transpose(t){const s=new y;return y.TransposeToRef(t,s),s}static TransposeToRef(t,s){const i=t.m,n=i[0],o=i[4],r=i[8],e=i[12],a=i[1],_=i[5],c=i[9],m=i[13],x=i[2],w=i[6],f=i[10],F=i[14],I=i[3],p=i[7],d=i[11],L=i[15],l=s._m;return l[0]=n,l[1]=o,l[2]=r,l[3]=e,l[4]=a,l[5]=_,l[6]=c,l[7]=m,l[8]=x,l[9]=w,l[10]=f,l[11]=F,l[12]=I,l[13]=p,l[14]=d,l[15]=L,s.markAsUpdated(),s._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),s}static Reflection(t){const s=new y;return y.ReflectionToRef(t,s),s}static ReflectionToRef(t,s){t.normalize();const i=t.normal.x,n=t.normal.y,o=t.normal.z,r=-2*i,e=-2*n,a=-2*o;return y.FromValuesToRef(r*i+1,e*i,a*i,0,r*n,e*n+1,a*n,0,r*o,e*o,a*o+1,0,r*t.d,e*t.d,a*t.d,1,s),s}static FromXYZAxesToRef(t,s,i,n){return y.FromValuesToRef(t._x,t._y,t._z,0,s._x,s._y,s._z,0,i._x,i._y,i._z,0,0,0,0,1,n),n}static FromQuaternionToRef(t,s){const i=t._x*t._x,n=t._y*t._y,o=t._z*t._z,r=t._x*t._y,e=t._z*t._w,a=t._z*t._x,_=t._y*t._w,c=t._y*t._z,m=t._x*t._w;return s._m[0]=1-2*(n+o),s._m[1]=2*(r+e),s._m[2]=2*(a-_),s._m[3]=0,s._m[4]=2*(r-e),s._m[5]=1-2*(o+i),s._m[6]=2*(c+m),s._m[7]=0,s._m[8]=2*(a+_),s._m[9]=2*(c-m),s._m[10]=1-2*(n+i),s._m[11]=0,s._m[12]=0,s._m[13]=0,s._m[14]=0,s._m[15]=1,s.markAsUpdated(),s}}y._IdentityReadOnly=y.Identity();Object.defineProperties(y.prototype,{dimension:{value:[4,4]},rank:{value:2}});class R{}R.Vector3=Q(11,h.Zero);R.Matrix=Q(2,y.Identity);R.Quaternion=Q(3,z.Zero);class ${}$.Vector2=Q(3,T.Zero);$.Vector3=Q(13,h.Zero);$.Vector4=Q(3,u.Zero);$.Quaternion=Q(3,z.Zero);$.Matrix=Q(8,y.Identity);st("BABYLON.Vector2",T);st("BABYLON.Vector3",h);st("BABYLON.Vector4",u);st("BABYLON.Matrix",y);const v=y.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);export{y as M,z as Q,$ as T,h as V,T as a};
