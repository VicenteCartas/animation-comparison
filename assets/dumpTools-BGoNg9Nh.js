import{E as I,e as S}from"./passPostProcess-B1BM1DGJ.js";import{T as m}from"./tools-gxnNlSsX.js";import{h as b,E as u}from"./worker-C-KDBD9A.js";import"./math.vector-85WCOQKP.js";import"./texture-DgySHbn6.js";import"./instantiationTools-Dje2H3Fn.js";let l,d=null;async function x(){return d||(d=new Promise((a,s)=>{let n,e=null;const o={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};import("./worker-C-KDBD9A.js").then(function(i){return i.Q}).then(({ThinEngine:i})=>{const f=u.Instances.length;try{n=new OffscreenCanvas(100,100),e=new i(n,!1,o)}catch{f<u.Instances.length&&u.Instances.pop()?.dispose(),n=document.createElement("canvas"),e=new i(n,!1,o)}u.Instances.pop(),u.OnEnginesDisposedObservable.add(r=>{e&&r!==e&&!e.isDisposed&&u.Instances.length===0&&v()}),e.getCaps().parallelShaderCompile=void 0;const p=new I(e);import("./pass.fragment-aaP79LUn.js").then(({passPixelShader:r})=>{if(!e){s("Engine is not defined");return}const t=new S({engine:e,name:r.name,fragmentShader:r.shader,samplerNames:["textureSampler"]});l={canvas:n,engine:e,renderer:p,wrapper:t},a(l)})}).catch(s)})),await d}async function y(a,s,n,e,o="image/png",i,f){const p=await n.readPixels(0,0,a,s),r=new Uint8Array(p.buffer);w(a,s,r,e,o,i,!0,void 0,f)}async function E(a,s,n,e="image/png",o,i=!1,f=!1,p){return await new Promise(r=>{w(a,s,n,t=>r(t),e,o,i,f,p)})}function w(a,s,n,e,o="image/png",i,f=!1,p=!1,r){x().then(t=>{if(t.engine.setSize(a,s,!0),n instanceof Float32Array){const g=new Uint8Array(n.length);let c=n.length;for(;c--;){const D=n[c];g[c]=Math.round(b(D)*255)}n=g}const h=t.engine.createRawTexture(n,a,s,5,!1,!f,1);t.renderer.setViewport(),t.renderer.applyEffectWrapper(t.wrapper),t.wrapper.effect._bindTexture("textureSampler",h),t.renderer.draw(),p?m.ToBlob(t.canvas,g=>{const c=new FileReader;c.onload=D=>{const A=D.target.result;e&&e(A)},c.readAsArrayBuffer(g)},o,r):m.EncodeScreenshotCanvasData(t.canvas,e,o,i,r),h.dispose()})}function v(){l?(l.wrapper.dispose(),l.renderer.dispose(),l.engine.dispose()):d?.then(a=>{a.wrapper.dispose(),a.renderer.dispose(),a.engine.dispose()}),d=null,l=null}const M={DumpData:w,DumpDataAsync:E,DumpFramebuffer:y,Dispose:v},C=()=>{m.DumpData=w,m.DumpDataAsync=E,m.DumpFramebuffer=y};C();export{v as Dispose,w as DumpData,E as DumpDataAsync,y as DumpFramebuffer,M as DumpTools};
