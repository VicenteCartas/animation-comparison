const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CNEoGfFH.js","assets/index-BitWEoNU.css","assets/pass.fragment-aVC8Zjis.js"])))=>i.map(i=>d[i]);
import{i as I,h as E,E as u}from"./index-CNEoGfFH.js";import{E as P,e as S}from"./passPostProcess-90fRZMdI.js";import{T as m}from"./tools-C8uRUird.js";import"./math.vector-Dy490sIj.js";import"./texture-Ua_cSNYb.js";import"./instantiationTools-C92SNS_Y.js";let l,d=null;async function x(){return d||(d=new Promise((t,s)=>{let n,e=null;const o={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};E(()=>import("./index-CNEoGfFH.js").then(i=>i.U),__vite__mapDeps([0,1])).then(({ThinEngine:i})=>{const p=u.Instances.length;try{n=new OffscreenCanvas(100,100),e=new i(n,!1,o)}catch{p<u.Instances.length&&u.Instances.pop()?.dispose(),n=document.createElement("canvas"),e=new i(n,!1,o)}u.Instances.pop(),u.OnEnginesDisposedObservable.add(a=>{e&&a!==e&&!e.isDisposed&&u.Instances.length===0&&y()}),e.getCaps().parallelShaderCompile=void 0;const f=new P(e);E(async()=>{const{passPixelShader:a}=await import("./pass.fragment-aVC8Zjis.js");return{passPixelShader:a}},__vite__mapDeps([2,0,1])).then(({passPixelShader:a})=>{if(!e){s("Engine is not defined");return}const r=new S({engine:e,name:a.name,fragmentShader:a.shader,samplerNames:["textureSampler"]});l={canvas:n,engine:e,renderer:f,wrapper:r},t(l)})}).catch(s)})),await d}async function _(t,s,n,e,o="image/png",i,p){const f=await n.readPixels(0,0,t,s),a=new Uint8Array(f.buffer);g(t,s,a,e,o,i,!0,void 0,p)}async function v(t,s,n,e="image/png",o,i=!1,p=!1,f){return await new Promise(a=>{g(t,s,n,r=>a(r),e,o,i,p,f)})}function g(t,s,n,e,o="image/png",i,p=!1,f=!1,a){x().then(r=>{if(r.engine.setSize(t,s,!0),n instanceof Float32Array){const w=new Uint8Array(n.length);let c=n.length;for(;c--;){const D=n[c];w[c]=Math.round(I(D)*255)}n=w}const h=r.engine.createRawTexture(n,t,s,5,!1,!p,1);r.renderer.setViewport(),r.renderer.applyEffectWrapper(r.wrapper),r.wrapper.effect._bindTexture("textureSampler",h),r.renderer.draw(),f?m.ToBlob(r.canvas,w=>{const c=new FileReader;c.onload=D=>{const A=D.target.result;e&&e(A)},c.readAsArrayBuffer(w)},o,a):m.EncodeScreenshotCanvasData(r.canvas,e,o,i,a),h.dispose()})}function y(){l?(l.wrapper.dispose(),l.renderer.dispose(),l.engine.dispose()):d?.then(t=>{t.wrapper.dispose(),t.renderer.dispose(),t.engine.dispose()}),d=null,l=null}const V={DumpData:g,DumpDataAsync:v,DumpFramebuffer:_,Dispose:y},R=()=>{m.DumpData=g,m.DumpDataAsync=v,m.DumpFramebuffer=_};R();export{y as Dispose,g as DumpData,v as DumpDataAsync,_ as DumpFramebuffer,V as DumpTools};
